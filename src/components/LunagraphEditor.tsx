"use client"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "./ui/Tabs"
import { useState } from "react"
import { DndContext, DragOverlay } from "@dnd-kit/core"
import { FEElement } from "./types"
import CanvasLayout from "./CanvasLayout"
import { Canvas } from "./Canvas"
import { InsertPanel } from "./InsertPanel"
import { LayersPanel } from "./LayersPanel"
import { useDndCanvas } from "./hooks/useDndCanvas"
import { renderElement } from "./utils/renderElement"
import { Text } from "./ui/Text"

export interface ComponentIndex {
  [componentName: string]: {
    path: string
    exportName: string
    props?: Record<string, any>
  }
}

export interface LunagraphEditorProps {
  /**
   * Map of component names to actual component functions
   * Example: import * as UI from '@/components/ui'
   * Then pass: components={UI}
   */
  components: Record<string, React.ComponentType<any>>

  /**
   * Component index generated by lunagraph scan
   * Example: import componentIndex from '@/.lunagraph/ComponentIndex.json'
   * Then pass: componentIndex={componentIndex}
   */
  componentIndex: ComponentIndex
}

export const LunagraphEditor = ({
  components,
  componentIndex,
}: LunagraphEditorProps) => {
  const [elements, setElements] = useState<FEElement[]>([])
  const [selectedElementId, setSelectedElementId] = useState<string | null>(null)
  const [hoverElementId, setHoverElementId] = useState<string | null>(null)

  const onDragElement = (
    draggedId: string,
    targetId: string | null,
    position: "before" | "after" | "inside"
  ) => {
    let draggedElement: FEElement | null = null;

    const findAndRemove = (elements: FEElement[]): FEElement[] => {
      const result: FEElement[] = [];
      for (const el of elements) {
        if (el.id === draggedId) {
          draggedElement = el;
        } else {
          if (el.type !== 'text') {
            result.push({
              ...el,
              children: el.children ? findAndRemove(el.children) : [],
            });
          } else {
            result.push(el);
          }
        }
      }
      return result;
    };

    const insertElement = (elements: FEElement[]): FEElement[] => {
      const result: FEElement[] = [];

      for (let i = 0; i < elements.length; i++) {
        const el = elements[i];

        if (el.id === targetId) {
          if (position === "before" && draggedElement) {
            result.push(draggedElement);
            result.push(el);
          } else if (position === "after" && draggedElement) {
            result.push(el);
            result.push(draggedElement);
          } else if (position === "inside" && draggedElement) {
            if (el.type !== 'text') {
              result.push({
                ...el,
                children: [...(el.children || []), draggedElement],
              });
            } else {
              result.push(el);
            }
          }
        } else {
          if (el.type !== 'text') {
            result.push({
              ...el,
              children: el.children ? insertElement(el.children) : [],
            });
          } else {
            result.push(el);
          }
        }
      }

      return result;
    };

    const newElements = findAndRemove(elements);
    const finalElements = insertElement(newElements);
    setElements(finalElements);
  }

  const {
    activeElement,
    overId,
    isDragging,
    handleDragStart,
    handleDragMove,
    handleDragEnd,
    handleDragCancel,
  } = useDndCanvas({
    elements,
    setElements,
    onSelectElement: setSelectedElementId,
    onDragElement,
  });

  const onAddElement = (element: FEElement) => {
    setElements(prev => [...prev, element])
  }

  const onResizeElement = (
    elementId: string,
    size: { width: number; height: number },
    pos?: { x: number; y: number }
  ) => {
    const updateElement = (elements: FEElement[]): FEElement[] => {
      return elements.map((el) => {
        if (el.id === elementId) {
          return {
            ...el,
            styles: {
              ...(el.styles || {}),
              width: size.width,
              height: size.height
            },
            canvasPosition: pos ? {x: pos?.x, y: pos?.y} : undefined
          };
        }
        if (el.type !== 'text') {
          return {
            ...el,
            children: el.children ? updateElement(el.children) : []
          };
        }
        return el;
      });
    };

    setElements(el => updateElement(el));
  }

  return (
    <CanvasLayout
      leftChildren={
        <div className="flex flex-col h-full overflow-hidden">
          <div className="p-2">
            <Text size="xs">Workspace</Text>
          </div>
          <Tabs defaultValue="layers" className="w-full gap-0 h-full overflow-hidden">
            <TabsList className="w-full p-2" variant="simple">
              <TabsTrigger value="layers">Layers</TabsTrigger>
              <TabsTrigger value="insert">Insert</TabsTrigger>
            </TabsList>
            <TabsContent value="layers" className="h-full overflow-hidden flex flex-col">
              <LayersPanel
                elements={elements}
                selectedElementId={selectedElementId}
                onSelectElement={setSelectedElementId}
                onDragElement={onDragElement}
              />
            </TabsContent>
            <TabsContent value="insert" className="h-full overflow-hidden flex flex-col">
              <InsertPanel
                onAddElement={onAddElement}
                componentIndex={componentIndex}
              />
            </TabsContent>
          </Tabs>
        </div>
      }
    >
      <DndContext
        onDragStart={handleDragStart}
        onDragMove={handleDragMove}
        onDragEnd={handleDragEnd}
        onDragCancel={handleDragCancel}
      >
        <Canvas
          elements={elements}
          selectedElementId={selectedElementId}
          hoverElementId={hoverElementId}
          onSelectElement={(id: string | null) => setSelectedElementId(id)}
          onHoverElement={(id: string | null) => setHoverElementId(id)}
          onResizeElement={onResizeElement}
          isDragging={isDragging}
          potentialParentId={overId}
          components={components}
        />
        <DragOverlay dropAnimation={null}>
          {activeElement && renderElement(activeElement, {
            isDragPreview: true,
            components,
          })}
        </DragOverlay>
      </DndContext>
    </CanvasLayout>
  )
}
