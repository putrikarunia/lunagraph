"use client"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "./ui/Tabs"
import { useState, useEffect, useCallback, useRef } from "react"
import { useRouter, useSearchParams } from "next/navigation"
import { DndContext, DragOverlay, useSensors, useSensor, PointerSensor } from "@dnd-kit/core"
import { FEElement } from "./types"
import CanvasLayout from "./CanvasLayout"
import { Canvas } from "./Canvas"
import { InsertPanel } from "./InsertPanel"
import { AssetsPanel } from "./AssetsPanel"
import { LayersPanel } from "./LayersPanel"
import StylesPanel from "./StylesPanel"
import PropsPanel from "./PropsPanel"
import { StatePanel } from "./StatePanel"
import { CreateComponentModal } from "./CreateComponentModal"
import { useDndCanvas } from "./hooks/useDndCanvas"
import { renderElement } from "./utils/renderElement"
import { generatePrefixedId } from "./utils/idUtils"
import { Text } from "./ui/Text"
import { BottomBar, EditorTab } from "./BottomBar"
import { useDevServer } from "../hooks/useDevServer"
import { useComponentSnapshot } from "../hooks/useComponentSnapshot"
import { useCanvasPersistence } from "../hooks/useCanvasPersistence"
import { findElement } from "./utils/treeUtils"
import { generateCompleteFile } from "@lunagraph/codegen"
import { X } from "@phosphor-icons/react"

// Helper to generate canvas slug from name
function slugify(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
}

export interface ComponentIndex {
  [componentName: string]: {
    path: string
    exportName: string
    props?: Record<string, any>
  }
}

export interface LunagraphEditorProps {
  /**
   * Map of component names to actual component functions
   * Example: import * as UI from '@/components/ui'
   * Then pass: components={UI}
   */
  components: Record<string, React.ComponentType<any>>

  /**
   * Component index generated by lunagraph scan
   * Example: import componentIndex from '@/.lunagraph/ComponentIndex.json'
   * Then pass: componentIndex={componentIndex}
   */
  componentIndex: ComponentIndex
}

export const LunagraphEditor = ({
  components,
  componentIndex,
}: LunagraphEditorProps) => {
  const router = useRouter()
  const searchParams = useSearchParams()
  const editingFile = searchParams.get('file')

  const [selectedElementId, setSelectedElementId] = useState<string | null>(null)
  const [hoverElementId, setHoverElementId] = useState<string | null>(null)
  const [editingTextId, setEditingTextId] = useState<string | null>(null)
  const [canvasZoom, setCanvasZoom] = useState(1)
  const [cmdPressed, setCmdPressed] = useState(false)
  const [showCreateComponentModal, setShowCreateComponentModal] = useState(false)

  // Track Cmd/Ctrl key for deep selection
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.metaKey || e.ctrlKey) {
        setCmdPressed(true)
      }
    }
    const handleKeyUp = (e: KeyboardEvent) => {
      if (!e.metaKey && !e.ctrlKey) {
        setCmdPressed(false)
      }
    }
    window.addEventListener('keydown', handleKeyDown)
    window.addEventListener('keyup', handleKeyUp)
    // Handle blur (when user switches windows while holding Cmd)
    const handleBlur = () => setCmdPressed(false)
    window.addEventListener('blur', handleBlur)
    return () => {
      window.removeEventListener('keydown', handleKeyDown)
      window.removeEventListener('keyup', handleKeyUp)
      window.removeEventListener('blur', handleBlur)
    }
  }, [])

  // Tabs state - always starts with Canvas 1
  const [tabs, setTabs] = useState<EditorTab[]>([{
    id: 'canvas-1',
    name: 'Canvas 1',
    type: 'canvas',
    canvasId: 'canvas-1',
    canvasPath: '.lunagraph/canvases/canvas-1/',
    elements: []
  }])
  const [activeTabId, setActiveTabId] = useState('canvas-1')

  const { loadFile, isLoading } = useDevServer()
  const { saveCanvas, loadCanvas, createComponent } = useCanvasPersistence()

  // Track last saved state to avoid unnecessary saves
  const lastSavedStateRef = useRef<string>('')

  // Load canvas-1 on mount
  useEffect(() => {
    const loadInitialCanvas = async () => {
      const result = await loadCanvas('canvas-1')
      if (result.success && result.canvas) {
        setTabs(prev => prev.map(tab =>
          tab.id === 'canvas-1'
            ? {
                ...tab,
                elements: result.canvas!.elements,
                canvasSaved: true,
              }
            : tab
        ))
        // Update last saved state to prevent immediate re-save
        lastSavedStateRef.current = JSON.stringify({
          elements: result.canvas.elements,
          zoom: 1,
        })
      }
    }
    loadInitialCanvas()
  }, []) // Only run on mount

  // Get active tab
  const activeTab = tabs.find(t => t.id === activeTabId)

  // Current elements = active tab's elements
  const elements = activeTab?.elements || []

  const elementsRef = useRef(elements)

  useEffect(() => {
    elementsRef.current = elements
  }, [elements])

  // Update active tab's elements (supports both direct value and updater function)
  const setElements = useCallback((newElements: FEElement[] | ((prev: FEElement[]) => FEElement[])) => {
    setTabs(prev => prev.map(tab => {
      if (tab.id !== activeTabId) return tab

      const updatedElements = typeof newElements === 'function'
        ? newElements(tab.elements)
        : newElements

      return { ...tab, elements: updatedElements }
    }))
  }, [activeTabId])

  // Generate elements from snapshot data when editing a file
  const snapshotElements = useComponentSnapshot({
    returnJSX: activeTab?.returnJSX || null,
    variables: activeTab?.variables || [],
    mockValues: activeTab?.mockValues || {},
    components,
    componentIndex,
  })

  // Update tab elements when snapshot renders
  useEffect(() => {
    if (activeTab?.type === 'file' && activeTab.returnJSX && snapshotElements.length > 0) {
      setTabs(prev => prev.map(tab =>
        tab.id === activeTabId ? { ...tab, elements: snapshotElements } : tab
      ))
    }
  }, [snapshotElements, activeTabId, activeTab?.type, activeTab?.returnJSX])

  const onEditComponent = async (componentName: string, filePath: string) => {
    // Check if tab already exists for this file
    const existingTab = tabs.find(tab => tab.filePath === filePath)
    if (existingTab) {
      // Switch to existing tab
      setActiveTabId(existingTab.id)
      router.push(`?file=${encodeURIComponent(filePath)}`)
      return
    }

    // Load file from dev server
    const result = await loadFile(filePath)

    if (!result.success) {
      console.error('Failed to load file:', result.error)
      // Still create tab but with empty data
      const newTab: EditorTab = {
        id: generatePrefixedId('file'),
        name: componentName,
        type: 'file',
        filePath,
        elements: []
      }
      setTabs(prev => [...prev, newTab])
      setActiveTabId(newTab.id)
      router.push(`?file=${encodeURIComponent(filePath)}`)
      return
    }

    // Create new tab with snapshot data
    // Elements will be generated by useComponentSnapshot hook
    const newTab: EditorTab = {
      id: generatePrefixedId('file'),
      name: componentName,
      type: 'file',
      filePath,
      elements: [], // Will be populated by snapshot rendering
      returnJSX: result.returnJSX,
      variables: result.variables,
      initialValues: result.initialValues,
      props: result.props,
      mockValues: result.initialValues, // Start with initialValues as mockValues
    }
    setTabs(prev => [...prev, newTab])
    setActiveTabId(newTab.id)
    router.push(`?file=${encodeURIComponent(filePath)}`)
  }

  const onTabChange = (tabId: string) => {
    setActiveTabId(tabId)
    const tab = tabs.find(t => t.id === tabId)
    if (tab?.type === 'file' && tab.filePath) {
      router.push(`?file=${encodeURIComponent(tab.filePath)}`)
    } else {
      router.push('/editor')
    }
  }

  const onTabClose = (tabId: string) => {
    const tabIndex = tabs.findIndex(t => t.id === tabId)
    const newTabs = tabs.filter(t => t.id !== tabId)
    setTabs(newTabs)

    // If closing active tab, switch to adjacent tab
    if (tabId === activeTabId) {
      const newActiveTab = newTabs[Math.max(0, tabIndex - 1)]
      setActiveTabId(newActiveTab.id)
      if (newActiveTab.type === 'file' && newActiveTab.filePath) {
        router.push(`?file=${encodeURIComponent(newActiveTab.filePath)}`)
      } else {
        router.push('/editor')
      }
    }
  }

  // Configure sensors with activation constraint to allow double-click
  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 5, // Drag only starts after moving 5px
      },
    })
  );

  const onDragElement = (
    draggedId: string,
    targetId: string | null,
    position: "before" | "after" | "inside"
  ) => {
    let draggedElement: FEElement | null = null;

    const findAndRemove = (elements: FEElement[]): FEElement[] => {
      const result: FEElement[] = [];
      for (const el of elements) {
        if (el.id === draggedId) {
          draggedElement = el;
        } else {
          if (el.type !== 'text') {
            result.push({
              ...el,
              children: el.children ? findAndRemove(el.children) : [],
            });
          } else {
            result.push(el);
          }
        }
      }
      return result;
    };

    const insertElement = (elements: FEElement[]): FEElement[] => {
      const result: FEElement[] = [];

      for (let i = 0; i < elements.length; i++) {
        const el = elements[i];

        if (el.id === targetId) {
          if (position === "before" && draggedElement) {
            result.push(draggedElement);
            result.push(el);
          } else if (position === "after" && draggedElement) {
            result.push(el);
            result.push(draggedElement);
          } else if (position === "inside" && draggedElement) {
            if (el.type !== 'text') {
              result.push({
                ...el,
                children: [...(el.children || []), draggedElement],
              });
            } else {
              result.push(el);
            }
          }
        } else {
          if (el.type !== 'text') {
            result.push({
              ...el,
              children: el.children ? insertElement(el.children) : [],
            });
          } else {
            result.push(el);
          }
        }
      }

      return result;
    };

    const newElements = findAndRemove(elements);
    const finalElements = insertElement(newElements);
    setElements(finalElements);
  }

  const {
    activeElement,
    overId,
    isDragging,
    handleDragStart,
    handleDragMove,
    handleDragEnd,
    handleDragCancel,
  } = useDndCanvas({
    elements,
    setElements,
    onSelectElement: setSelectedElementId,
    onDragElement,
    canvasScale: canvasZoom,
  });

  const onAddElement = (element: FEElement) => {
    setElements(prev => [...prev, element])
  }

  const onResizeElement = useCallback((
    elementId: string,
    size: { width: number; height: number },
    pos?: { x: number; y: number }
  ) => {
    const updateElement = (elements: FEElement[]): FEElement[] => {
      return elements.map((el) => {
        if (el.id === elementId) {
          return {
            ...el,
            styles: {
              ...(el.styles || {}),
              width: size.width,
              height: size.height
            },
            canvasPosition: pos ? {x: pos?.x, y: pos?.y} : undefined
          };
        }
        if (el.type !== 'text') {
          return {
            ...el,
            children: el.children ? updateElement(el.children) : []
          };
        }
        return el;
      });
    };

    setElements(el => updateElement(el));
  }, [])

  const onDeleteElement = (elementId: string) => {
    const removeElement = (elements: FEElement[]): FEElement[] => {
      return elements.reduce((acc, el) => {
        if (el.id === elementId) {
          // Skip this element (delete it)
          return acc;
        }
        if (el.type !== 'text' && el.children) {
          // Recursively remove from children
          acc.push({
            ...el,
            children: removeElement(el.children)
          });
        } else {
          acc.push(el);
        }
        return acc;
      }, [] as FEElement[]);
    };

    setElements(removeElement);
    setSelectedElementId(null); // Clear selection after delete
  }

  const onDuplicateElement = (elementId: string) => {
    // Helper to recursively clone element with new IDs
    const cloneWithNewIds = (element: FEElement): FEElement => {
      const el = structuredClone(element)
      const newId = generatePrefixedId(el.type);

      if (el.type === 'text') {
        return {
          ...el,
          id: newId,
        };
      }

      return {
        ...el,
        id: newId,
        children: el.children ? el.children.map(cloneWithNewIds) : undefined,
        // Offset canvas position if it exists
        canvasPosition: el.canvasPosition
          ? { x: el.canvasPosition.x + 20, y: el.canvasPosition.y + 20 }
          : undefined
      } as FEElement;
    };

    // Helper to find and duplicate element
    const duplicateInTree = (elements: FEElement[]): { found: boolean; elements: FEElement[] } => {
      const result: FEElement[] = [];
      let found = false;

      for (const el of elements) {
        if (el.id === elementId) {
          // Found it! Add original (deep cloned) and duplicate
          result.push(el);
          const duplicate = cloneWithNewIds(el);
          result.push(duplicate);
          found = true;
        } else if (el.type !== 'text' && el.children) {
          // Recursively search in children
          const childResult = duplicateInTree(el.children);
          if (childResult.found) {
            // Create new element reference with updated children
            result.push({
              ...el,
              children: childResult.elements
            });
            found = true;
          } else {
            // No match in children, keep original
            result.push(el);
          }
        } else {
          // Leaf element (text) or no children, keep original
          result.push(el);
        }
      }

      return { found, elements: result };
    };

    const { elements: newElements } = duplicateInTree(elementsRef.current);
    setElements(newElements);
  }

  const onDoubleClickDrillIn = (elementId: string, x: number, y: number) => {
    // Find all elements at the click position
    const elementsAtPoint = document.elementsFromPoint(x, y);
    const elementIds: string[] = [];

    for (const el of elementsAtPoint) {
      const id = el.getAttribute('data-element-id');
      if (id) {
        elementIds.push(id);
      }
    }

    // Find the element that was double-clicked
    const clickedIndex = elementIds.indexOf(elementId);
    if (clickedIndex === -1 || clickedIndex === 0) {
      // Can't drill in further (already at deepest level or element not found)
      return;
    }

    // Select the next deeper element (one level down in the hierarchy)
    const childId = elementIds[clickedIndex - 1];
    setSelectedElementId(childId);
  }

  const onEditText = (elementId: string, text: string) => {
    const updateText = (elements: FEElement[]): FEElement[] => {
      return elements.map((el) => {
        if (el.id === elementId && el.type === 'text') {
          return {
            ...el,
            text,
          };
        }
        if (el.type !== 'text' && el.children) {
          return {
            ...el,
            children: updateText(el.children)
          };
        }
        return el;
      });
    };

    setElements(updateText);
  }

  const onUpdateElementStyles = (elementId: string, styles: React.CSSProperties) => {
    const updateStyles = (elements: FEElement[]): FEElement[] => {
      return elements.map((el) => {
        if (el.id === elementId) {
          return {
            ...el,
            styles,
          };
        }
        if (el.type !== 'text' && el.children) {
          return {
            ...el,
            children: updateStyles(el.children)
          };
        }
        return el;
      });
    };

    setElements(updateStyles);
  }

  const onUpdateElementProps = (elementId: string, props: Record<string, any>) => {
    const updateProps = (elements: FEElement[]): FEElement[] => {
      return elements.map((el) => {
        if (el.id === elementId && el.type === 'component') {
          return {
            ...el,
            props,
          };
        }
        if (el.type !== 'text' && el.children) {
          return {
            ...el,
            children: updateProps(el.children)
          };
        }
        return el;
      });
    };

    setElements(updateProps);
  }

  const onCreateComponent = async (componentName: string) => {
    if (!selectedElementId || activeTab?.type !== 'canvas' || !activeTab.canvasId) {
      console.error('Cannot create component: no element selected or not in canvas')
      return
    }

    // Find the selected element
    const element = findElement(elements, selectedElementId)
    if (!element) {
      console.error('Selected element not found')
      return
    }

    // Generate component code
    const code = generateCompleteFile({
      componentName,
      elements: [element],
      componentIndex,
      targetFilePath: `.lunagraph/canvases/${activeTab.canvasId}/components/${componentName}.tsx`
    })

    // Save component to dev server
    const result = await createComponent({
      canvasId: activeTab.canvasId,
      componentName,
      code
    })

    if (!result.success) {
      console.error('Failed to create component:', result.error)
      return
    }

    // Replace element in canvas with component reference
    const replaceElement = (els: FEElement[]): FEElement[] => {
      return els.map((el) => {
        if (el.id === selectedElementId) {
          // Replace with component instance
          // Don't preserve styles - component has its own styles
          // Only preserve canvasPosition for layout
          return {
            id: generatePrefixedId('component'),
            type: 'component',
            componentName,
            props: {},
            ...(el.type !== 'text' && el.canvasPosition ? { canvasPosition: el.canvasPosition } : {}),
          } as FEElement
        }
        if (el.type !== 'text' && el.children) {
          return {
            ...el,
            children: replaceElement(el.children)
          }
        }
        return el
      })
    }

    setElements(replaceElement)
    setSelectedElementId(null)

    console.log('âœ“ Component created:', componentName, 'at', result.path)
  }

  const onUpdateMockValue = useCallback((name: string, value: any) => {
    setTabs(prev => prev.map(tab => {
      if (tab.id !== activeTabId || tab.type !== 'file') return tab

      return {
        ...tab,
        mockValues: {
          ...tab.mockValues,
          [name]: value
        }
      }
    }))
  }, [activeTabId])

  const onReloadFile = useCallback(async (filePath: string) => {
    // Reload the file to get updated content after save
    const result = await loadFile(filePath)

    if (!result.success) {
      console.error('Failed to reload file:', result.error)
      return
    }

    // Update the tab with new snapshot data
    setTabs(prev => prev.map(tab => {
      if (tab.filePath !== filePath) return tab

      return {
        ...tab,
        returnJSX: result.returnJSX,
        variables: result.variables,
        initialValues: result.initialValues,
        props: result.props,
        mockValues: result.initialValues, // Reset to new initial values
        // Keep existing elements - will be updated by snapshot rendering
      }
    }))
  }, [loadFile])

  // Auto-save canvas on changes
  useEffect(() => {
    if (activeTab?.type !== 'canvas' || !activeTab.canvasId) return

    // Create current state snapshot
    const currentState = JSON.stringify({
      elements: activeTab.elements,
      zoom: canvasZoom,
    })

    // Skip if nothing changed
    if (currentState === lastSavedStateRef.current) return

    const timeout = setTimeout(async () => {
      await saveCanvas({
        id: activeTab.canvasId,
        name: activeTab.name,
        elements: activeTab.elements,
        zoom: canvasZoom,
      })

      // Update last saved state
      lastSavedStateRef.current = currentState

      // Mark as saved
      setTabs(prev => prev.map(tab =>
        tab.id === activeTab.id ? { ...tab, canvasSaved: true } : tab
      ))
    }, 1000) // Debounce 1s

    return () => clearTimeout(timeout)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [activeTab?.elements, canvasZoom, activeTab?.id, activeTab?.canvasId])

  // Handle keyboard shortcuts (delete, duplicate, create component)
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Don't trigger shortcuts if user is typing in an input/textarea
      const target = e.target as HTMLElement;
      if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {
        return;
      }

      // Delete: Delete or Backspace
      if ((e.key === 'Delete' || e.key === 'Backspace') && selectedElementId) {
        e.preventDefault();
        onDeleteElement(selectedElementId);
      }

      // Duplicate: Cmd+D (Mac) or Ctrl+D (Windows/Linux)
      if ((e.metaKey || e.ctrlKey) && e.key === 'd' && selectedElementId) {
        e.preventDefault();
        onDuplicateElement(selectedElementId);
      }

      // Create Component: Option+Cmd+K (Mac) or Alt+Ctrl+K (Windows/Linux)
      if ((e.metaKey || e.ctrlKey) && e.altKey && e.key === 'k' && selectedElementId) {
        e.preventDefault();
        setShowCreateComponentModal(true);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [selectedElementId]);

  return (
    <CanvasLayout
      leftChildren={
        <div className="flex flex-col h-full overflow-hidden">
          <div className="p-2">
            <Text size="xs">Workspace</Text>
          </div>
          <Tabs defaultValue="layers" className="w-full gap-0 h-full overflow-hidden">
            <TabsList className="w-full p-2" variant="simple">
              <TabsTrigger value="layers">Layers</TabsTrigger>
              <TabsTrigger value="insert">Insert</TabsTrigger>
              <TabsTrigger value="assets">Assets</TabsTrigger>
            </TabsList>
            <TabsContent value="layers" className="h-full overflow-hidden flex flex-col">
              <LayersPanel
                elements={elements}
                selectedElementId={selectedElementId}
                onSelectElement={setSelectedElementId}
                onDragElement={onDragElement}
              />
            </TabsContent>
            <TabsContent value="insert" className="h-full overflow-hidden flex flex-col">
              <InsertPanel
                onAddElement={onAddElement}
              />
            </TabsContent>
            <TabsContent value="assets" className="h-full overflow-hidden flex flex-col">
              <AssetsPanel
                onAddElement={onAddElement}
                componentIndex={componentIndex}
                onEditComponent={onEditComponent}
              />
            </TabsContent>
          </Tabs>
        </div>
      }
      rightChildren={
        <div className="h-full flex flex-col overflow-hidden">
          <Tabs defaultValue="element" className="h-full flex flex-col">
            <TabsList className="w-full p-2" variant="simple">
              <TabsTrigger value="element">Element</TabsTrigger>
              <TabsTrigger value="state">State</TabsTrigger>
            </TabsList>
            <TabsContent value="state" className="flex-1 overflow-hidden">
              <StatePanel
                variables={activeTab?.variables || []}
                mockValues={activeTab?.mockValues || {}}
                initialValues={activeTab?.initialValues || {}}
                props={activeTab?.props || []}
                onUpdateMockValue={onUpdateMockValue}
              />
            </TabsContent>
            <TabsContent value="element" className="flex-1 overflow-hidden flex flex-col">
              <PropsPanel
                selectedElementId={selectedElementId}
                elements={elements}
                componentIndex={componentIndex}
                onUpdateElementProps={onUpdateElementProps}
              />
              <StylesPanel
                selectedElementId={selectedElementId}
                elements={elements}
                onUpdateElementStyles={onUpdateElementStyles}
                onCreateComponent={() => setShowCreateComponentModal(true)}
              />
            </TabsContent>
          </Tabs>
        </div>
      }
      bottomChildren={
        <BottomBar tab={activeTab!} onSaveSuccess={onReloadFile} />
      }
    >
      {/* Tabs wrap canvas + bottom code */}
      <Tabs value={activeTabId} onValueChange={onTabChange} className="h-full flex flex-col">
        {/* Tab bar at top */}
        <div className="flex items-center border-b border-border bg-muted/30">
          <TabsList variant="simple" className="border-0 gap-0 h-auto">
            {tabs.map((tab) => (
              <div key={tab.id} className="group relative flex items-center border-r border-border">
                <TabsTrigger value={tab.id} className="px-4 py-2.5 text-sm pr-8 rounded-none">
                  {tab.name}
                </TabsTrigger>
                {tabs.length > 1 && (
                  <span
                    onClick={() => onTabClose(tab.id)}
                    className="absolute right-2 opacity-0 group-hover:opacity-100 hover:bg-accent rounded p-1 cursor-pointer transition-opacity"
                  >
                    <X size={14} weight="bold" className="text-muted-foreground" />
                  </span>
                )}
              </div>
            ))}
          </TabsList>
        </div>

        {/* Each tab's canvas */}
        {tabs.map((tab) => (
          <TabsContent key={tab.id} value={tab.id} className="flex-1 m-0">
            <DndContext
              sensors={sensors}
              onDragStart={handleDragStart}
              onDragMove={handleDragMove}
              onDragEnd={handleDragEnd}
              onDragCancel={handleDragCancel}
            >
              <Canvas
                elements={tab.elements}
                selectedElementId={selectedElementId}
                hoverElementId={hoverElementId}
                onSelectElement={(id: string | null) => setSelectedElementId(id)}
                onHoverElement={(id: string | null) => setHoverElementId(id)}
                onDoubleClickDrillIn={onDoubleClickDrillIn}
                onResizeElement={onResizeElement}
                onEditText={onEditText}
                editingTextId={editingTextId}
                onStartEditText={setEditingTextId}
                onStopEditText={() => setEditingTextId(null)}
                isDragging={isDragging}
                potentialParentId={overId}
                components={components}
                componentIndex={componentIndex}
                onZoomChange={setCanvasZoom}
                cmdPressed={cmdPressed}
              />
              <DragOverlay dropAnimation={null}>
                {activeElement && (
                  <div style={{ transform: `scale(${canvasZoom})`, transformOrigin: 'top left' }}>
                    {renderElement(activeElement, {
                      isDragPreview: true,
                      components,
                      componentIndex,
                    })}
                  </div>
                )}
              </DragOverlay>
            </DndContext>
          </TabsContent>
        ))}
      </Tabs>

      {/* Create Component Modal */}
      <CreateComponentModal
        isOpen={showCreateComponentModal}
        onClose={() => setShowCreateComponentModal(false)}
        onConfirm={onCreateComponent}
      />
    </CanvasLayout>
  )
}
