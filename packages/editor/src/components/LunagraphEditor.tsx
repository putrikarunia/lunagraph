"use client"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "./ui/Tabs"
import { useState, useEffect, useCallback, useRef } from "react"
import { useRouter, useSearchParams } from "next/navigation"
import { DndContext, DragOverlay, useSensors, useSensor, PointerSensor } from "@dnd-kit/core"
import { FEElement } from "./types"
import CanvasLayout from "./CanvasLayout"
import { Canvas } from "./Canvas"
import { InsertPanel } from "./InsertPanel"
import { AssetsPanel } from "./AssetsPanel"
import { LayersPanel } from "./LayersPanel"
import StylesPanel from "./StylesPanel"
import PropsPanel from "./PropsPanel"
import { StatePanel } from "./StatePanel"
import { useDndCanvas } from "./hooks/useDndCanvas"
import { renderElement } from "./utils/renderElement"
import { Text } from "./ui/Text"
import { BottomBar, EditorTab } from "./BottomBar"
import { useDevServer } from "../hooks/useDevServer"
import { useComponentSnapshot } from "../hooks/useComponentSnapshot"
import { X } from "@phosphor-icons/react"

export interface ComponentIndex {
  [componentName: string]: {
    path: string
    exportName: string
    props?: Record<string, any>
  }
}

export interface LunagraphEditorProps {
  /**
   * Map of component names to actual component functions
   * Example: import * as UI from '@/components/ui'
   * Then pass: components={UI}
   */
  components: Record<string, React.ComponentType<any>>

  /**
   * Component index generated by lunagraph scan
   * Example: import componentIndex from '@/.lunagraph/ComponentIndex.json'
   * Then pass: componentIndex={componentIndex}
   */
  componentIndex: ComponentIndex
}

export const LunagraphEditor = ({
  components,
  componentIndex,
}: LunagraphEditorProps) => {
  const router = useRouter()
  const searchParams = useSearchParams()
  const editingFile = searchParams.get('file')

  const [selectedElementId, setSelectedElementId] = useState<string | null>(null)
  const [hoverElementId, setHoverElementId] = useState<string | null>(null)
  const [editingTextId, setEditingTextId] = useState<string | null>(null)
  const [canvasZoom, setCanvasZoom] = useState(1)

  // Tabs state - always starts with Canvas 1
  const [tabs, setTabs] = useState<EditorTab[]>([{
    id: 'canvas-1',
    name: 'Canvas 1',
    type: 'canvas',
    elements: []
  }])
  const [activeTabId, setActiveTabId] = useState('canvas-1')

  const { loadFile, isLoading } = useDevServer()

  // Get active tab
  const activeTab = tabs.find(t => t.id === activeTabId)

  // Current elements = active tab's elements
  const elements = activeTab?.elements || []

  // Update active tab's elements (supports both direct value and updater function)
  const setElements = useCallback((newElements: FEElement[] | ((prev: FEElement[]) => FEElement[])) => {
    setTabs(prev => prev.map(tab => {
      if (tab.id !== activeTabId) return tab

      const updatedElements = typeof newElements === 'function'
        ? newElements(tab.elements)
        : newElements

      return { ...tab, elements: updatedElements }
    }))
  }, [activeTabId])

  // Generate elements from snapshot data when editing a file
  const snapshotElements = useComponentSnapshot({
    returnJSX: activeTab?.returnJSX || null,
    variables: activeTab?.variables || [],
    mockValues: activeTab?.mockValues || {},
    components,
    componentIndex,
  })

  // Update tab elements when snapshot renders
  useEffect(() => {
    if (activeTab?.type === 'file' && activeTab.returnJSX && snapshotElements.length > 0) {
      setTabs(prev => prev.map(tab =>
        tab.id === activeTabId ? { ...tab, elements: snapshotElements } : tab
      ))
    }
  }, [snapshotElements, activeTabId, activeTab?.type, activeTab?.returnJSX])

  const onEditComponent = async (componentName: string, filePath: string) => {
    // Check if tab already exists for this file
    const existingTab = tabs.find(tab => tab.filePath === filePath)
    if (existingTab) {
      // Switch to existing tab
      setActiveTabId(existingTab.id)
      router.push(`?file=${encodeURIComponent(filePath)}`)
      return
    }

    // Load file from dev server
    const result = await loadFile(filePath)

    if (!result.success) {
      console.error('Failed to load file:', result.error)
      // Still create tab but with empty data
      const newTab: EditorTab = {
        id: `file-${Date.now()}`,
        name: componentName,
        type: 'file',
        filePath,
        elements: []
      }
      setTabs(prev => [...prev, newTab])
      setActiveTabId(newTab.id)
      router.push(`?file=${encodeURIComponent(filePath)}`)
      return
    }

    // Create new tab with snapshot data
    // Elements will be generated by useComponentSnapshot hook
    const newTab: EditorTab = {
      id: `file-${Date.now()}`,
      name: componentName,
      type: 'file',
      filePath,
      elements: [], // Will be populated by snapshot rendering
      returnJSX: result.returnJSX,
      variables: result.variables,
      initialValues: result.initialValues,
      props: result.props,
      mockValues: result.initialValues, // Start with initialValues as mockValues
    }
    setTabs(prev => [...prev, newTab])
    setActiveTabId(newTab.id)
    router.push(`?file=${encodeURIComponent(filePath)}`)
  }

  const onTabChange = (tabId: string) => {
    setActiveTabId(tabId)
    const tab = tabs.find(t => t.id === tabId)
    if (tab?.type === 'file' && tab.filePath) {
      router.push(`?file=${encodeURIComponent(tab.filePath)}`)
    } else {
      router.push('/editor')
    }
  }

  const onTabClose = (tabId: string) => {
    const tabIndex = tabs.findIndex(t => t.id === tabId)
    const newTabs = tabs.filter(t => t.id !== tabId)
    setTabs(newTabs)

    // If closing active tab, switch to adjacent tab
    if (tabId === activeTabId) {
      const newActiveTab = newTabs[Math.max(0, tabIndex - 1)]
      setActiveTabId(newActiveTab.id)
      if (newActiveTab.type === 'file' && newActiveTab.filePath) {
        router.push(`?file=${encodeURIComponent(newActiveTab.filePath)}`)
      } else {
        router.push('/editor')
      }
    }
  }

  // Configure sensors with activation constraint to allow double-click
  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 5, // Drag only starts after moving 5px
      },
    })
  );

  const onDragElement = (
    draggedId: string,
    targetId: string | null,
    position: "before" | "after" | "inside"
  ) => {
    let draggedElement: FEElement | null = null;

    const findAndRemove = (elements: FEElement[]): FEElement[] => {
      const result: FEElement[] = [];
      for (const el of elements) {
        if (el.id === draggedId) {
          draggedElement = el;
        } else {
          if (el.type !== 'text') {
            result.push({
              ...el,
              children: el.children ? findAndRemove(el.children) : [],
            });
          } else {
            result.push(el);
          }
        }
      }
      return result;
    };

    const insertElement = (elements: FEElement[]): FEElement[] => {
      const result: FEElement[] = [];

      for (let i = 0; i < elements.length; i++) {
        const el = elements[i];

        if (el.id === targetId) {
          if (position === "before" && draggedElement) {
            result.push(draggedElement);
            result.push(el);
          } else if (position === "after" && draggedElement) {
            result.push(el);
            result.push(draggedElement);
          } else if (position === "inside" && draggedElement) {
            if (el.type !== 'text') {
              result.push({
                ...el,
                children: [...(el.children || []), draggedElement],
              });
            } else {
              result.push(el);
            }
          }
        } else {
          if (el.type !== 'text') {
            result.push({
              ...el,
              children: el.children ? insertElement(el.children) : [],
            });
          } else {
            result.push(el);
          }
        }
      }

      return result;
    };

    const newElements = findAndRemove(elements);
    const finalElements = insertElement(newElements);
    setElements(finalElements);
  }

  const {
    activeElement,
    overId,
    isDragging,
    handleDragStart,
    handleDragMove,
    handleDragEnd,
    handleDragCancel,
  } = useDndCanvas({
    elements,
    setElements,
    onSelectElement: setSelectedElementId,
    onDragElement,
    canvasScale: canvasZoom,
  });

  const onAddElement = (element: FEElement) => {
    setElements(prev => [...prev, element])
  }

  const onResizeElement = useCallback((
    elementId: string,
    size: { width: number; height: number },
    pos?: { x: number; y: number }
  ) => {
    const updateElement = (elements: FEElement[]): FEElement[] => {
      return elements.map((el) => {
        if (el.id === elementId) {
          return {
            ...el,
            styles: {
              ...(el.styles || {}),
              width: size.width,
              height: size.height
            },
            canvasPosition: pos ? {x: pos?.x, y: pos?.y} : undefined
          };
        }
        if (el.type !== 'text') {
          return {
            ...el,
            children: el.children ? updateElement(el.children) : []
          };
        }
        return el;
      });
    };

    setElements(el => updateElement(el));
  }, [])

  const onDeleteElement = (elementId: string) => {
    const removeElement = (elements: FEElement[]): FEElement[] => {
      return elements.reduce((acc, el) => {
        if (el.id === elementId) {
          // Skip this element (delete it)
          return acc;
        }
        if (el.type !== 'text' && el.children) {
          // Recursively remove from children
          acc.push({
            ...el,
            children: removeElement(el.children)
          });
        } else {
          acc.push(el);
        }
        return acc;
      }, [] as FEElement[]);
    };

    setElements(removeElement);
    setSelectedElementId(null); // Clear selection after delete
  }

  const onEditText = (elementId: string, text: string) => {
    const updateText = (elements: FEElement[]): FEElement[] => {
      return elements.map((el) => {
        if (el.id === elementId && el.type === 'text') {
          return {
            ...el,
            text,
          };
        }
        if (el.type !== 'text' && el.children) {
          return {
            ...el,
            children: updateText(el.children)
          };
        }
        return el;
      });
    };

    setElements(updateText);
  }

  const onUpdateElementStyles = (elementId: string, styles: React.CSSProperties) => {
    const updateStyles = (elements: FEElement[]): FEElement[] => {
      return elements.map((el) => {
        if (el.id === elementId) {
          return {
            ...el,
            styles,
          };
        }
        if (el.type !== 'text' && el.children) {
          return {
            ...el,
            children: updateStyles(el.children)
          };
        }
        return el;
      });
    };

    setElements(updateStyles);
  }

  const onUpdateElementProps = (elementId: string, props: Record<string, any>) => {
    const updateProps = (elements: FEElement[]): FEElement[] => {
      return elements.map((el) => {
        if (el.id === elementId && el.type === 'component') {
          return {
            ...el,
            props,
          };
        }
        if (el.type !== 'text' && el.children) {
          return {
            ...el,
            children: updateProps(el.children)
          };
        }
        return el;
      });
    };

    setElements(updateProps);
  }

  const onUpdateMockValue = useCallback((name: string, value: any) => {
    setTabs(prev => prev.map(tab => {
      if (tab.id !== activeTabId || tab.type !== 'file') return tab

      return {
        ...tab,
        mockValues: {
          ...tab.mockValues,
          [name]: value
        }
      }
    }))
  }, [activeTabId])

  const onReloadFile = useCallback(async (filePath: string) => {
    // Reload the file to get updated content after save
    const result = await loadFile(filePath)

    if (!result.success) {
      console.error('Failed to reload file:', result.error)
      return
    }

    // Update the tab with new snapshot data
    setTabs(prev => prev.map(tab => {
      if (tab.filePath !== filePath) return tab

      return {
        ...tab,
        returnJSX: result.returnJSX,
        variables: result.variables,
        initialValues: result.initialValues,
        props: result.props,
        mockValues: result.initialValues, // Reset to new initial values
        // Keep existing elements - will be updated by snapshot rendering
      }
    }))
  }, [loadFile])

  // Handle keyboard delete
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if ((e.key === 'Delete' || e.key === 'Backspace') && selectedElementId) {
        // Don't delete if user is typing in an input/textarea
        const target = e.target as HTMLElement;
        if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {
          return;
        }

        e.preventDefault();
        onDeleteElement(selectedElementId);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [selectedElementId]);

  return (
    <CanvasLayout
      leftChildren={
        <div className="flex flex-col h-full overflow-hidden">
          <div className="p-2">
            <Text size="xs">Workspace</Text>
          </div>
          <Tabs defaultValue="layers" className="w-full gap-0 h-full overflow-hidden">
            <TabsList className="w-full p-2" variant="simple">
              <TabsTrigger value="layers">Layers</TabsTrigger>
              <TabsTrigger value="insert">Insert</TabsTrigger>
              <TabsTrigger value="assets">Assets</TabsTrigger>
            </TabsList>
            <TabsContent value="layers" className="h-full overflow-hidden flex flex-col">
              <LayersPanel
                elements={elements}
                selectedElementId={selectedElementId}
                onSelectElement={setSelectedElementId}
                onDragElement={onDragElement}
              />
            </TabsContent>
            <TabsContent value="insert" className="h-full overflow-hidden flex flex-col">
              <InsertPanel
                onAddElement={onAddElement}
              />
            </TabsContent>
            <TabsContent value="assets" className="h-full overflow-hidden flex flex-col">
              <AssetsPanel
                onAddElement={onAddElement}
                componentIndex={componentIndex}
                onEditComponent={onEditComponent}
              />
            </TabsContent>
          </Tabs>
        </div>
      }
      rightChildren={
        <div className="h-full flex flex-col overflow-hidden">
          <Tabs defaultValue="state" className="h-full flex flex-col">
            <TabsList className="w-full p-2" variant="simple">
              <TabsTrigger value="state">State</TabsTrigger>
              <TabsTrigger value="element">Element</TabsTrigger>
            </TabsList>
            <TabsContent value="state" className="flex-1 overflow-hidden">
              <StatePanel
                variables={activeTab?.variables || []}
                mockValues={activeTab?.mockValues || {}}
                initialValues={activeTab?.initialValues || {}}
                props={activeTab?.props || []}
                onUpdateMockValue={onUpdateMockValue}
              />
            </TabsContent>
            <TabsContent value="element" className="flex-1 overflow-hidden flex flex-col">
              <PropsPanel
                selectedElementId={selectedElementId}
                elements={elements}
                componentIndex={componentIndex}
                onUpdateElementProps={onUpdateElementProps}
              />
              <StylesPanel
                selectedElementId={selectedElementId}
                elements={elements}
                onUpdateElementStyles={onUpdateElementStyles}
              />
            </TabsContent>
          </Tabs>
        </div>
      }
      bottomChildren={
        <BottomBar tab={activeTab!} onSaveSuccess={onReloadFile} />
      }
    >
      {/* Tabs wrap canvas + bottom code */}
      <Tabs value={activeTabId} onValueChange={onTabChange} className="h-full flex flex-col">
        {/* Tab bar at top */}
        <div className="flex items-center border-b border-border bg-muted/30">
          <TabsList variant="simple" className="border-0 gap-0 h-auto">
            {tabs.map((tab) => (
              <div key={tab.id} className="group relative flex items-center border-r border-border">
                <TabsTrigger value={tab.id} className="px-4 py-2.5 text-sm pr-8 rounded-none">
                  {tab.name}
                </TabsTrigger>
                {tabs.length > 1 && (
                  <span
                    onClick={() => onTabClose(tab.id)}
                    className="absolute right-2 opacity-0 group-hover:opacity-100 hover:bg-accent rounded p-1 cursor-pointer transition-opacity"
                  >
                    <X size={14} weight="bold" className="text-muted-foreground" />
                  </span>
                )}
              </div>
            ))}
          </TabsList>
        </div>

        {/* Each tab's canvas */}
        {tabs.map((tab) => (
          <TabsContent key={tab.id} value={tab.id} className="flex-1 m-0">
            <DndContext
              sensors={sensors}
              onDragStart={handleDragStart}
              onDragMove={handleDragMove}
              onDragEnd={handleDragEnd}
              onDragCancel={handleDragCancel}
            >
              <Canvas
                elements={tab.elements}
                selectedElementId={selectedElementId}
                hoverElementId={hoverElementId}
                onSelectElement={(id: string | null) => setSelectedElementId(id)}
                onHoverElement={(id: string | null) => setHoverElementId(id)}
                onResizeElement={onResizeElement}
                onEditText={onEditText}
                editingTextId={editingTextId}
                onStartEditText={setEditingTextId}
                onStopEditText={() => setEditingTextId(null)}
                isDragging={isDragging}
                potentialParentId={overId}
                components={components}
                componentIndex={componentIndex}
                onZoomChange={setCanvasZoom}
              />
              <DragOverlay dropAnimation={null}>
                {activeElement && (
                  <div style={{ transform: `scale(${canvasZoom})`, transformOrigin: 'top left' }}>
                    {renderElement(activeElement, {
                      isDragPreview: true,
                      components,
                      componentIndex,
                    })}
                  </div>
                )}
              </DragOverlay>
            </DndContext>
          </TabsContent>
        ))}
      </Tabs>
    </CanvasLayout>
  )
}
